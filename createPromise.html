<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    const PENGDING = 'pengding'
    const FULFILLED = 'fulfilled'
    const REJECTED = 'rejected'

    function MyPromise(executor) {
      let self = this
      self.state = PENGDING
      self.value = null
      self.reason = null
      self.onFuifilledCallbacks = []
      self.onRejectedCallbacks = []

      // 接受成功函数
      function resolve(value) {
        // 如果正在进行中  改变状态  成功
        if (self.state === PENGDING) {
          self.state = FULFILLED
          self.value = value

          self.onFuifilledCallbacks.forEach(function (fulfilledCallback) {
            fulfilledCallback()
          });
        }
      }

      // 接受失败原因
      function reject(reason) {
        // 如果正在进行中 改变状态  失败
        if (self.state === PENGDING) {
          self.state = REJECTED
          self.reason = reason

          self.onRejectedCallbacks
        }
      }

      try {
        console.log(executor)
        executor(resolve, reject);
      } catch (reason) {
        reject(reason);
      }
    }

    MyPromise.prototype.then = function (onFuifilled, onRejected) {
      let self = this
      let promise2 = null
      promise2 = new MyPromise((resolve, reject) => {
        if (self.state === PENGDING) {
          self.onFuifilledCallbacks.push(() => {
            try {
              let x = onFuifilled(self.value)
              self.resolvePromise(promise2, x, resolve, reject)
            } catch (reason) {
              reject(reason)
            }
          })

          self.onRejectedCallbacks.push(() => {
            try {
              let x = onRejected(self.reason)
              self.resolvePromise(promise2, x, resolve, reject)
            } catch (reason) {
              reject(reason)
            }
          })
        }

        if (self.state === FULFILLED) {
          try {
            let x = onRejected(self.value)
            self.resolvePromise(promise2, x, resolve, reject)
          } catch (reason) {
            reject(reason)
          }
        }

        if (self.state === REJECTED) {
          try {
            let x = onRejected(self.reason)
            self.resolvePromise(promise2, x, resolve, reject)
          } catch (reason) {
            reject(reason)
          }
        }
        return promise2
      })

    }

    MyPromise.prototype.resolvePromise = fucntion(promise2, x, resolve, reject) {
      let self = this
      let called = false

      if (promise2 === x) {
        return reject(new TypeError('循环调用'))
      }

      if (x !== null && (Object.prototype.toString.call(x) === '[object Object]' || Object.prototype.toString.call(x) === '[object Function]')) {
        // x 是对象 或者  函数
        try {
          let  then = x.then
          i
        }
      }
    }


  </script>
</body>

</html>